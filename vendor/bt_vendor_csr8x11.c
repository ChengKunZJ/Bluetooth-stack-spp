#include "bt_vendor_csr8x11.h"
#include "bt_hci.h"
#include "serial_init.h"
#include <stdlib.h>
#include <string.h>


/************************************************************** ***********************************
HCI command  PACKETS Format:
	opcode 16 bit
	para total len 8 bit
	para 0
**************************************************************************************************/

/*************************************************************************************************
BCCMD PACKETS Format:
           |	  type   |	length   |	seqno   |		varid	|	status   |	payload������	|
 uint 16   |	    1    |   2     |    3   |       4     |     5    |        6~     |
**************************************************************************************************/

/*************************************************************************************************
BCCMD PS PACKETS Format:
           |	  header  |	key   |	length    |	stores      |		ps value  	|
 uint 16   |	    1-5   |    6    |      7     |       8        |      9~           |
**************************************************************************************************/
// minimal CSR init script to configure PSKEYs and activate them
uint8_t csr8x11_initscript[] =
{
    //  Set PSKEY_DEEP_SLEEP_STATE never deep sleep
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x02, 0x00, 0x03, 0x70, 0x00, 0x00, 0x29, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,

    //  Set ANA_Freq to 26MHz
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x70, 0x00, 0x00, 0xfe, 0x01, 0x01, 0x00, 0x08, 0x00, 0x90, 0x65,

    //  Set CSR_PSKEY_ANA_FTRIM 0x24 for csr8811
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x04, 0x00, 0x03, 0x70, 0x00, 0x00, 0xf6, 0x01, 0x01, 0x00, 0x08, 0x00, 0x24, 0x00,

    // Set CSR_PSKEY_DEFAULT_TRANSMIT_POWER 0x4
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x05, 0x00, 0x03, 0x70, 0x00, 0x00, 0x21, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,

    // Set CSR_PSKEY_MAXIMUM_TRANSMIT_POWER 0x4
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x06, 0x00, 0x03, 0x70, 0x00, 0x00, 0x17, 0x00, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,

    // Set CSR_PSKEY_BLE_DEFAULT_TRANSMIT_POWER 0x4
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x07, 0x00, 0x03, 0x70, 0x00, 0x00, 0xc8, 0x22, 0x01, 0x00, 0x08, 0x00, 0x04, 0x00,

    // Set CSR_PSKEY_BDADDR
    0x19, 0xc2, 0x02, 0x00, 0x0c, 0x00, 0x08, 0x00, 0x03, 0x70, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x08, 0x00, 0x20, 0x00, 0x98, 0x1a, 0x86, 0x00, 0x1d, 0x00,

    // Set CSR_PSKEY_PCM_CONFIG32
    0x15, 0xc2, 0x02, 0x00, 0x0a, 0x00, 0x09, 0x00, 0x03, 0x70, 0x00, 0x00, 0xb3, 0x01, 0x02, 0x00, 0x08, 0x00, 0x80, 0x08, 0x80, 0x18,

    // Set CSR_PSKEY_PCM_FORMAT 0x60
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x03, 0x70, 0x00, 0x00, 0xb6, 0x01, 0x01, 0x00, 0x08, 0x00, 0x60, 0x00,

    // Set CSR_PSKEY_USER_LOW_JITTER_MODE
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x0b, 0x00, 0x03, 0x70, 0x00, 0x00, 0xc9, 0x23, 0x01, 0x00, 0x08, 0x00, 0x01, 0x00,

    //  Set HCI_NOP_DISABLE
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x0c, 0x00, 0x03, 0x70, 0x00, 0x00, 0xf2, 0x00, 0x01, 0x00, 0x08, 0x00, 0x01, 0x00,

    // Set UART baudrate to 921600
    // 0x15, 0xc2, 0x02, 0x00, 0x0a, 0x00, 0x0d, 0x00, 0x03, 0x70, 0x00, 0x00, 0xea, 0x01, 0x02, 0x00, 0x08, 0x00,0x0e,0x00,0x00,0x10,/*0x1b, 0x00, 0x40, 0x77,*/

    //  WarmReset
    0x13, 0xc2, 0x02, 0x00, 0x09, 0x00, 0x0e, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
int prepare_pos = 0;
unsigned char *pcsr8x11_initscript;

void csr8x11_vendor_init(void (*vendor_init_done_cb)(uint8_t), uint8_t ogf, uint8_t ocf)
{
    struct bt_pbuf_t *p;
    uint16_t size = 0;
    uint16_t varid;
    pcsr8x11_initscript = csr8x11_initscript+prepare_pos;
    size = pcsr8x11_initscript[0];
    prepare_pos += (size+1);
    uint8_t *vendor_buf = (uint8_t *)malloc(size + 3);

    varid = bt_le_read_16(pcsr8x11_initscript,8);
    
    TRACE_INFO("vendor init");

    
    if( vendor_buf == NULL)
    {
        TRACE_ERROR("ERROR:file[%s] vendor_buf malloc fail",__FILE__);
        return;
    }
    memset(vendor_buf, 0, size + 3);

    /* Assembling command packet */
    hci_cmd_ass(vendor_buf, 0, HCI_VENDOR_OGF, size+3);

    memcpy((uint8_t *)vendor_buf+3,pcsr8x11_initscript+1,size);
    /* Assembling cmd prameters */
    phybusif_output(vendor_buf, size + 3,HCI_CMD_PKT);

    free(vendor_buf);


    if(varid == WARM_RESET)
    {
    	// phybusif_reopen(BAUD_RATE_2);
        vendor_init_done_cb(VENDOR_STATUS_INITED);
    }
}